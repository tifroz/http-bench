// Generated by CoffeeScript 1.3.1
var BenchClient, Benchmark, benchmark, http, https, program, url, util, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

http = require('http');

https = require('https');

url = require('url');

util = require('util');

program = require('commander');

_ = require('underscore');

process.on('uncaughtException', function(err) {
  console.error("uncaughtException");
  console.error(err);
  return process.exit(1);
});

program.version('0.0.1').usage('[options] <url e.g "http://www.google.com/index.html">').option('-c, --concurrency <n>', 'Number of concurrent clients (default: 1)', parseInt, 1).option('-r, --ramp <n>', 'Time to ramp up clients (default: 1s)', parseInt, 1).option('-t, --think <n>', 'Think time (default: 1s)', parseInt, 1).option('-T, --timeout <n>', 'Request timeout (default: 60s)', parseInt, 60).option('-d, --duration <n>', 'Test duration excluding ramp-up time and ramp-down times (default: 60s)', parseInt, 60).option('-c, --concurrency <n>', 'Number of concurrent clients (default: 1)', parseInt, 1).parse(process.argv);

program.url = url.parse(program.args.pop());

Benchmark = (function() {
  var _clients, _pending, _results, _status;

  Benchmark.name = 'Benchmark';

  _clients = [];

  _status = null;

  _pending = 0;

  _results = {
    errors: [],
    successes: []
  };

  function Benchmark(params) {
    var i, _i, _ref;
    this.params = params;
    this.printAndExit = __bind(this.printAndExit, this);

    this.removePending = __bind(this.removePending, this);

    this.addPending = __bind(this.addPending, this);

    this.addError = __bind(this.addError, this);

    this.addSuccess = __bind(this.addSuccess, this);

    this.getStatus = __bind(this.getStatus, this);

    this.stop = __bind(this.stop, this);

    this.createClient = __bind(this.createClient, this);

    _status = 'started';
    for (i = _i = 1, _ref = this.params.concurrency; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      setTimeout(this.createClient, Math.round(i * this.params.ramp * 1000 / this.params.concurrency));
    }
  }

  Benchmark.prototype.createClient = function() {
    try {
      _clients.push(new BenchClient(this.params, this));
      if (_clients.length === this.params.concurrency) {
        _status = 'wip';
        return setTimeout(this.stop, this.params.duration * 1000);
      }
    } catch (boo) {
      return console.error(boo);
    }
  };

  Benchmark.prototype.stop = function() {
    _status = 'stopped';
    if (_pending === 0) {
      return this.printAndExit();
    }
  };

  Benchmark.prototype.getStatus = function() {
    return _status;
  };

  Benchmark.prototype.addSuccess = function(success) {
    return _results.successes.push(success);
  };

  Benchmark.prototype.addError = function(error) {
    var err;
    err = _.find(_results.errors, function(e) {
      return _.isEqual(e.instance, error);
    });
    if (err) {
      return err.count += 1;
    } else {
      return _results.errors.push({
        instance: error,
        count: 1
      });
    }
  };

  Benchmark.prototype.addPending = function(client) {
    return _pending += 1;
  };

  Benchmark.prototype.removePending = function(client) {
    _pending -= 1;
    if (_status === 'stopped' && _pending === 0) {
      return this.printAndExit();
    }
  };

  Benchmark.prototype.printAndExit = function() {
    var e, errorCount, successes, totalTime, _i, _len, _ref;
    successes = _.sortBy(_results.successes, function(s) {
      return s.elapsed;
    });
    errorCount = _.reduce(_results.errors, (function(m, e) {
      return m += e.count;
    }), 0);
    totalTime = _.reduce(successes, (function(m, r) {
      return m + r.elapsed;
    }), 0);
    console.log("Requests: " + (errorCount + successes.length));
    console.log("Errors: " + errorCount);
    _ref = _results.errors;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      console.log("\t- " + e.count + " occurence(s) of " + (util.format('%j', e.instance)));
    }
    if (successes.length > 0) {
      console.log("Average Time: " + (Math.round(totalTime / successes.length)) + "ms");
      console.log("95 percentile: " + successes[Math.round(successes.length * 0.95)].elapsed + "ms");
      console.log("90 percentile: " + successes[Math.round(successes.length * 0.90)].elapsed + "ms");
      console.log("80 percentile: " + successes[Math.round(successes.length * 0.80)].elapsed + "ms");
      console.log("70 percentile: " + successes[Math.round(successes.length * 0.70)].elapsed + "ms");
      console.log("60 percentile: " + successes[Math.round(successes.length * 0.60)].elapsed + "ms");
    }
    return process.exit(0);
  };

  return Benchmark;

})();

BenchClient = (function() {
  var _controller, _options, _reqOptions;

  BenchClient.name = 'BenchClient';

  _options = null;

  _reqOptions = null;

  _controller = null;

  function BenchClient(options, controller) {
    this.handleError = __bind(this.handleError, this);

    this.scheduleRequest = __bind(this.scheduleRequest, this);

    this.sendRequest = __bind(this.sendRequest, this);
    _reqOptions = {
      hostname: options.url.hostname,
      port: options.url.port,
      path: options.url.path,
      agent: false,
      method: 'GET'
    };
    _options = {
      protocol: options.url.protocol === 'https' ? https : http,
      think: options.think * 1000,
      timeout: options.timeout * 1000
    };
    _controller = controller;
    this.sendRequest();
  }

  BenchClient.prototype.sendRequest = function() {
    var abortRequest, req, startedTime, timeout,
      _this = this;
    startedTime = Date.now();
    req = _options.protocol.request(_reqOptions, function(res) {
      return res.on('end', function() {
        var elapsed;
        elapsed = Date.now() - startedTime;
        clearTimeout(timeout);
        if (res.statusCode !== 200) {
          _this.handleError(res);
        } else {
          _controller.addSuccess({
            elapsed: elapsed
          });
          _controller.removePending(_this);
        }
        return setTimeout(_this.scheduleRequest, _options.think);
      });
    });
    abortRequest = function() {
      clearTimeout(timeout);
      req.abort();
      return _this.handleError('timeout');
    };
    timeout = setTimeout(abortRequest, _options.timeout);
    req.on('error', function(err) {
      return _this.handleError;
    });
    req.end();
    return _controller.addPending(this);
  };

  BenchClient.prototype.scheduleRequest = function() {
    if (_controller.getStatus() !== 'stopped') {
      return this.sendRequest();
    }
  };

  BenchClient.prototype.handleError = function(err) {
    _controller.removePending(this);
    return _controller.addError(err);
  };

  return BenchClient;

})();

benchmark = new Benchmark(program);
