// Generated by CoffeeScript 1.6.3
var BenchClient, Benchmark, benchmark, http, https, program, url, util, verbose, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

http = require('http');

https = require('https');

url = require('url');

util = require('util');

program = require('commander');

_ = require('underscore');

process.on('uncaughtException', function(err) {
  console.error("uncaughtException: " + err.message);
  console.error(err.stack);
  return process.exit(1);
});

program.version('0.0.6').usage('[options] <url e.g "http://www.google.com/index.html">').option('-c, --concurrency <n>', 'Number of concurrent clients (default: 1)', parseInt, 1).option('-r, --ramp <n>', 'Time to ramp up clients (default: 1s)', parseInt, 1).option('-t, --think <n>', 'Think time (default: 1s)', parseInt, 1).option('-d, --duration <n>', 'Test duration excluding ramp-up time and ramp-down times (default: 60s)', parseInt, 60).option('-T, --timeout <n>', 'Request timeout (default: 60s)', parseInt, 60).option('-p, --partials <n>', 'Print partial results every n seconds (0 to disable  - this is the default)', parseInt, 0).option('-v, --verbose', 'Verbose logs (for debugging)').parse(process.argv);

verbose = function() {
  if (program.verbose) {
    return console.log.apply(this, arguments);
  }
};

program.url = url.parse(program.args.pop());

if (program.verbose) {
  console.log(util.format("Options:\n%s\n\n", util.inspect(program)));
}

Benchmark = (function() {
  function Benchmark(params) {
    var i, _i, _ref;
    this.params = params;
    this.printAndExit = __bind(this.printAndExit, this);
    this.print = __bind(this.print, this);
    this.removePending = __bind(this.removePending, this);
    this.addPending = __bind(this.addPending, this);
    this.addError = __bind(this.addError, this);
    this.addSuccess = __bind(this.addSuccess, this);
    this.getStatus = __bind(this.getStatus, this);
    this.stop = __bind(this.stop, this);
    this.createClient = __bind(this.createClient, this);
    this._results = {
      errors: [],
      successes: []
    };
    this._clients = [];
    this._pending = 0;
    this._status = 'started';
    this._partials = null;
    for (i = _i = 1, _ref = this.params.concurrency; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      setTimeout(this.createClient, Math.round(i * this.params.ramp * 1000 / this.params.concurrency));
    }
    if (this.params.partials > 0) {
      this._partials = setInterval(this.print, this.params.partials * 1000);
    }
    process.on("exit", this.print);
    process.on('SIGINT', (function() {
      return process.exit(1);
    }));
  }

  Benchmark.prototype.createClient = function() {
    var boo;
    try {
      this._clients.push(new BenchClient(this.params, this));
      if (this._clients.length === this.params.concurrency) {
        this._status = 'wip';
        return setTimeout(this.stop, this.params.duration * 1000);
      }
    } catch (_error) {
      boo = _error;
      return console.error(boo);
    }
  };

  Benchmark.prototype.stop = function() {
    this._status = 'stopped';
    clearInterval(this._partials);
    if (program.verbose) {
      return console.log('stopped');
    }
  };

  Benchmark.prototype.getStatus = function() {
    return this._status;
  };

  Benchmark.prototype.addSuccess = function(success) {
    verbose("" + this._pending + " pending requests (1 added), " + success.elapsed + "ms elapsed");
    return this._results.successes.push(success);
  };

  Benchmark.prototype.addError = function(error) {
    var err;
    err = _.find(this._results.errors, function(e) {
      return _.isEqual(e.instance, error);
    });
    if (err) {
      return err.count += 1;
    } else {
      return this._results.errors.push({
        instance: error,
        count: 1
      });
    }
  };

  Benchmark.prototype.addPending = function(client) {
    this._pending += 1;
    return verbose("" + this._pending + " pending requests (1 added)");
  };

  Benchmark.prototype.removePending = function(client) {
    this._pending -= 1;
    return verbose("" + this._pending + " pending requests (1 removed)");
  };

  Benchmark.prototype.print = function() {
    var e, errorCount, successes, totalTime, _i, _len, _ref;
    successes = _.sortBy(this._results.successes, function(s) {
      return s.elapsed;
    });
    errorCount = _.reduce(this._results.errors, (function(m, e) {
      return m += e.count;
    }), 0);
    totalTime = _.reduce(successes, (function(m, r) {
      return m + r.elapsed;
    }), 0);
    console.log("Requests: " + (errorCount + successes.length));
    console.log("Errors: " + errorCount);
    _ref = this._results.errors;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      console.log("\t- " + e.count + " occurence(s) of " + (util.format('%j', e.instance)));
    }
    if (successes.length > 0) {
      console.log("Average Time: " + (Math.round(totalTime / successes.length)) + "ms");
      console.log("95 percentile: " + successes[Math.floor(successes.length * 0.95)].elapsed + "ms");
      console.log("90 percentile: " + successes[Math.floor(successes.length * 0.90)].elapsed + "ms");
      console.log("80 percentile: " + successes[Math.floor(successes.length * 0.80)].elapsed + "ms");
      console.log("70 percentile: " + successes[Math.floor(successes.length * 0.70)].elapsed + "ms");
      console.log("60 percentile: " + successes[Math.floor(successes.length * 0.60)].elapsed + "ms");
    }
    return console.log("*********************************\n\n");
  };

  Benchmark.prototype.printAndExit = function() {
    this.print();
    return process.exit(0);
  };

  return Benchmark;

})();

BenchClient = (function() {
  function BenchClient(options, controller) {
    this.handleError = __bind(this.handleError, this);
    this.scheduleRequest = __bind(this.scheduleRequest, this);
    this.sendRequest = __bind(this.sendRequest, this);
    this._reqOptions = {
      hostname: options.url.hostname,
      port: options.url.port,
      path: options.url.path,
      agent: false,
      method: 'GET'
    };
    this._options = {
      protocol: options.url.protocol === 'https:' ? https : http,
      think: options.think * 1000,
      timeout: options.timeout * 1000
    };
    this._controller = controller;
    this.sendRequest();
  }

  BenchClient.prototype.sendRequest = function() {
    var abortRequest, req, startedTime, timeout,
      _this = this;
    startedTime = Date.now();
    verbose("Sending request %s", util.inspect(this._reqOptions));
    req = this._options.protocol.request(this._reqOptions, function(res) {
      verbose("http status: %s", res.statusCode);
      res.on('error', _this.handleError);
      res.on('data', (function() {}));
      return res.on('end', function() {
        var elapsed;
        elapsed = Date.now() - startedTime;
        verbose("http v " + res.httpVersion + ", duration " + elapsed + "ms");
        clearTimeout(timeout);
        if (res.statusCode !== 200) {
          _this.handleError(new Error("Received http code " + res.statusCode));
        } else {
          _this._controller.addSuccess({
            elapsed: elapsed
          });
          _this._controller.removePending(_this);
        }
        return setTimeout(_this.scheduleRequest, _this._options.think);
      });
    });
    req.on('error', this.handleError);
    abortRequest = function() {
      clearTimeout(timeout);
      req.abort();
      _this.handleError(new Error('timeout'));
      return setTimeout(_this.scheduleRequest, _this._options.think);
    };
    timeout = setTimeout(abortRequest, this._options.timeout);
    req.on('error', this.handleError);
    req.end();
    return this._controller.addPending(this);
  };

  BenchClient.prototype.scheduleRequest = function() {
    if (this._controller.getStatus() !== 'stopped') {
      return this.sendRequest();
    }
  };

  BenchClient.prototype.handleError = function(err) {
    verbose(err.message);
    this._controller.removePending(this);
    return this._controller.addError(err);
  };

  return BenchClient;

})();

benchmark = new Benchmark(program);

/*
console.log 'sending mock request'

params = 
	method: 'GET'
	hostname: 'dev.swishly.com'
	path: '/proxy_are_you_here'
	port: null
	agent: false
req = http.get params, (res)->
	console.log("Got response: " + res.statusCode)
	res.on 'data', ->
		console.log 'data received'
	res.on 'end', ->
		console.log 'response received'
	res.on 'error', (err)->
		console.log 'response error'
req.on 'error', (err)->
	console.log "Request error: #{err.message}"
*/

